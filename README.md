# Robotic Warehouse (a sketch)

This is a draft of a robotic warehouse simulator.

# The idea

We want to have a simulated robotis warehouse to be able to compare different kinds of pathfinding
algorithms for robots working in this warehouse. We'll have one type of a robot, occupying
one pixel on a square grid. These robots will be able to move around, carry things, and also
pick them up and store them in both loading/unloading bays and warehouse racks.

The trick of this sketch is that we want be half-way between a more-or-less realistic system design
(with microservices, independent robots, asynchronous communications via a message queue etc.) and
an efficient simulation environment. We also want to be able to run different types of tests,
and compare different types of pathfinding approaches. So we'll aim for something in-between:
some aspects of the system will be radically simplified (like for example, that robots are just
pixels on a grid), while others may look slightly overengineered.

# Running the project

Clone the repo. Run `/src/robowh/main.py`. In a browser, run `http://localhost:5000/`.

To mess with the stuff, clone and install it as a package with `pip install -e .`.

# Architecture overview

The system consists of several units:
1. **GUI** - a front-end, vibe-coded in JS, talking to a flask backend
2. **View** - a flask backend responding to requests from the Visualizer
3. **Universe** - mostly a time-engine. IRL robots would move around on their own and communicate with the orchestrator asynchronously. In this model we have a singleton Physics engine that nudges other players one by one, allowing them to perform certan actions. It's not true concurrency, but for this purpose it's good enough. In practice will work with turns (time ticks), and each turn will take a certain amount of time. During a turn, robots will be given priority in random order. If all of them manage to get processed, great! If not, the turn will be over, and the priority will be passed to system operations (Observer, Scheduler), until a new turn is started.
4. **Orchestrator** - the main logic of the warehouse: receiving orders from scheduler, assigning storage positions to incoming loads, remembering positions of stored goods, assigning tasks to robots.
5. **Robots** - each robot is an object that interfaces with Physics (on movement and other robot-driven actions) and with the Orchestrator (getting tasks from it, and reporting back)
6. **Strategies** - abstracted pathfinding methods that for a given start and end points calculate a given number of steps in the direction of this point
6. **Observer** - collects diagnostic information about the state of the system
7. **Scheduler** - creates tasks for robots; acts as a (fake) external interface of the warehouse
8. **Strategies** - abstract algorithms that receive information about a required subtask (for now limited to moving from point A to point B) and output some actions for a robot to follow (UDLR movements + wait)

The ontology of behaviors:
* Orders - come "from the exernal world" (in our case, in practice, are generated by the Scheduler), placed in a queue
* Tasks - assigned by the orchestrator. For robots tasks consist of actions.
* Actions - most tasks consist of several actions, a typical task for a typical robot is broken into at least 4 tasks: come to A, pick an order, move to B, drop an order.
* A queue of planned next moves - a part of a planned motion, generated for an action by a staregy
* Individual move

One weird semantic issue is that movements of robots may happen at several different levels of organization. We may want to just move robots around to resolve bottlenecks; movements come up during task execution, as parts of it; and then movement is planned, and finally elementary movements on the grid are happening as well. Let's use different words for this. It's not an ideal list of course, but better than nothing haha:
* A task that is movement-only we will call `reposition`
* An action within a task that is about moving from A to B we'll call `go`
* A sequence of next elementary steps we'll call `next_moves`
* Finally, elementary moves we'll call `move`

TODO:
* Add a more reasonable pathfinding algo
* Add handling of `idle` task
* Count the number of robots that are currently idling, show in the UI
* Add rack functionality (registrer places, with addresses, track inventory)
* Add target address functionality for incoming loads
* Add loading bay functionality
* Full task creation for incoming loads
* Make the button "add 20 more loads" work
* Full task creation for outgoing loads
* Improve unit test for robots, as towards the end it seems to be making strange assumptions
* Make "confused" element in UI actually report the number of confused robots

Nice to haves:
* The handling of sigletons is still a bit awkward: Universe is the only true singleton, and it creates others, except for the viewer, that is created in the main script. But also, to most (except for robots), universe is passed as a parameter, while for robots we break circular references using a deferred import (ugly). How to best standardize this? Should we always pass a reference to the universe explicitly at object creation, or is there a better way?
