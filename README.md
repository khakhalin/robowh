# Robotic Warehouse (a sketch)

This is a draft of a robotic warehouse simulator.

# The idea

We want to have a simulated robotic warehouse to be able to compare different kinds of pathfinding algorithms for robots working in this warehouse. We have one type of a robot, occupying one pixel on a square grid. These robots can to move around, carry items, and pick and store in both loading/unloading bays and warehouse racks.

The trick of this sketch is that we want to be half-way between a more-or-less realistic system design (with microservices, independent robots, asynchronous communications via message queues and stacks etc.) and a (relatively) efficient simulation environment. We also want to be able to run tests, and compare different pathfinding approaches. So we'll aim for something in-between:
some aspects of the system will be radically simplified (like for example, that robots are just
pixels on a grid), while others may look slightly overengineered.

# Running the project

Clone the repo. Run `/src/robowh/main.py`. In a browser, run `http://localhost:5000/`.

To mess with the stuff, clone and install it as a package with `pip install -e .`.

# Architecture overview

The system consists of several units:
1. **GUI** - a front-end, vibe-coded in JS, talking to a flask backend
2. **View** - a flask backend responding to requests from the Visualizer
3. **Universe** - mostly a time-engine. IRL robots would move around on their own and communicate with the orchestrator asynchronously. In this model we have a singleton Universe engine that nudges other players (both microservices and robots) one by one, allowing them to perform certan actions. It's not true concurrency, but for this purpose it's good enough. In practice we will work with turns (time ticks), and each turn will take a fixed amount of time. During a turn, robots will be given priority in random order. If all of them manage to get processed, great! If not, the turn will be over, and the priority will be passed to system operations (Observer, Scheduler), until a new turn is started.
4. **Orchestrator** - the main logic of the warehouse: receiving orders from scheduler, assigning storage positions to incoming loads, remembering positions of stored goods, assigning tasks to robots.
5. **Robots** - each robot is an object that interfaces with Universe (on movement and other robot-driven actions) and with the Orchestrator (getting tasks from it, and reporting back)
6. **Strategies** - abstracted pathfinding methods that for a given start and end points calculate a given number of steps in the direction of this point
6. **Observer** - collects diagnostic information about the state of the system
7. **Scheduler** - creates tasks for robots; acts as a (fake) external interface of the warehouse
8. **Strategies** - abstract algorithms that receive information about a required subtask (for now limited to moving from point A to point B) and output some actions for a robot to follow (UDLR movements + wait)

The ontology of behaviors:
* Orders - come "from the exernal world" (in our case, in practice, are generated by the Scheduler), placed in a queue
* Tasks - assigned by the orchestrator. For robots tasks consist of actions.
* Actions - most tasks consist of several actions, a typical task for a typical robot is broken into at least 4 tasks: come to A, pick an order, move to B, drop an order.
* A queue of planned next moves - a part of a planned motion, generated for an action by a staregy
* Individual move

One weird semantic issue is that movements of robots may happen at several different levels of organization. We may want to just move robots around to resolve bottlenecks; movements come up during task execution, as parts of it; and then movement is planned, and finally elementary movements on the grid are happening as well. Let's use different words for this. It's not an ideal list of course, but better than nothing haha:
* A task that is movement-only we will call `reposition`
* An action within a task that is about moving from A to B we'll call `go`
* A sequence of next elementary steps we'll call `next_moves`
* Finally, elementary moves we'll call `move`

TODO:
* Count the number of robots that were processed (didn't time out), show it in the console
* Add rack functionality (registrer places, with addresses, track inventory)
* Add target address functionality for incoming loads
* Add loading bay functionality
* Full task creation for incoming loads
* Full task creation for outgoing loads
* Add handling of `idle` task
* Make the button "add 20 more loads" work
* Measure and report confusins and blockage for robots
* Improve unit test for robots, as towards the end it seems to be making strange assumptions
* Make "confused" element in UI actually report the number of confused robots

Nice to haves:
* Revise the singleton situation. The handling of sigletons is still a bit awkward: Universe is the only true singleton, and it creates others, except for the viewer, that is created in the main script. But also, to most (except for robots), universe is passed as a parameter, while for robots we break circular references using a deferred import (ugly). How to best standardize this? Should we always pass a reference to the universe explicitly at object creation, or is there a better way?